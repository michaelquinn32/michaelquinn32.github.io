x <- rnorm(100)
# Test atomic version
self_lookup(x, nbins = 10, id = 2)
hash <- function(x, nbins) {
seq_along(x) %>% cut(nbins, label = FALSE) %>% split(sort(x), .)
}
# Check to see if a value is within the values given by an array
is_within <- function(vec, x) {
(min(vec) <= x) && (x <= max(vec))
}
# Find list entry that contains a value x
lookup <- function(x, list, cut_fun = head) {
vapply(list, is_within, x = x, logical(1)) %>% which
}
hash(x)
hash(x, 10)
vapply(hash(x), is_within, x = 2, logical(1)) %>% which
vapply(hash(x, 10), is_within, x = 2, logical(1)) %>% which
lookup(2, hash(x, 10))
hash <- function(x, nbins) {
seq_along(x) %>% cut(nbins, label = FALSE) %>% split(sort(x), .)
}
# Check to see if a value is within the values given by an array
is_within <- function(vec, x) {
(min(vec) <= x) && (x <= max(vec))
}
# Find list entry that contains a value x
lookup <- function(y, list) {
vapply(list, is_within, x = y, logical(1)) %>% which
}
# Combine the previous two functions
a_hash_lookup <- function(y, x, nbins) {
if (!is.list(x)) x <- hash(x, nbins)
y %>% lookup(x) %>% setNames(y)
}
# Create a vectorized version
v_hash_lookup <- function(y, x, nbins) {
if (!is.list(x)) x <- hash(x, nbins)
y %>% lapply(a_hash_lookup, x = x, nbins) %>% setNames(y)
}
# Self lookup
self_lookup <- function(x, nbins, id) {
if (length(id) == 1) a_hash_lookup(x[id], x, nbins)
else v_hash_lookup(x[id], x, nbins)
}
# Test Vector
x <- rnorm(100)
# Test atomic version
self_lookup(x, nbins = 10, id = 2)
which(x[2] == sort(x))
hash(x, 10) %>% sapply(length)
self_lookup(x, nbins = 10, id = 1:10)
v_hash_lookup <- function(y, x, nbins) {
if (!is.list(x)) x <- hash(x, nbins)
y %>% lapply(a_hash_lookup, x = x, nbins)
}
1:10 %>% sapply(function(id) which(x[id] == sort(x)))
self_lookup(x, nbins = 10, id = 1:10)
self_lookup(x, nbins = 10, id = 2)
self_lookup(x, nbins = 10, id = 1:10) %>% unlist
self_lookup <- function(x, nbins, id = seq_along(x)) {
if (length(id) == 1) a_hash_lookup(x[id], x, nbins)
else v_hash_lookup(x[id], x, nbins)
}
lapply(iris[-5], self_lookup, 10)
a_hash_lookup <- function(y, x, nbins) {
if (!is.list(x)) x <- hash(x, nbins)
y %>% lookup(x)
}
# Create a vectorized version
v_hash_lookup <- function(y, x, nbins) {
if (!is.list(x)) x <- hash(x, nbins)
y %>% lapply(a_hash_lookup, x = x, nbins) %>% setNames(y)
}
lapply(iris[-5], self_lookup, 10)
#' This is a fun hashing experiment
# Prelim
library(magrittr)
library(dplyr)
# Separate a vector into equal-value bins, cut reallocates overflow
hash <- function(x, nbins) {
seq_along(x) %>% cut(nbins, label = FALSE) %>% split(sort(x), .)
}
# Check to see if a value is within the values given by an array
is_within <- function(vec, x) {
(min(vec) <= x) && (x <= max(vec))
}
# Find list entry that contains a value x
lookup <- function(y, list) {
vapply(list, is_within, x = y, logical(1)) %>% which
}
# Combine the previous two functions
a_hash_lookup <- function(y, x, nbins) {
if (!is.list(x)) x <- hash(x, nbins)
y %>% lookup(x)
}
# Create a vectorized version
v_hash_lookup <- function(y, x, nbins) {
if (!is.list(x)) x <- hash(x, nbins)
y %>% lapply(a_hash_lookup, x = x, nbins) %>% setNames(y)
}
# Self lookup
self_lookup <- function(x, nbins, id = seq_along(x)) {
if (length(id) == 1) a_hash_lookup(x[id], x, nbins)
else v_hash_lookup(x[id], x, nbins)
}
# Test Vector
x <- rnorm(100)
# Check hash output
hash(x, 10) %>% sapply(length)
# Test atomic version
self_lookup(x, nbins = 10, id = 2)
which(x[2] == sort(x))
# Test vector version
self_lookup(x, nbins = 10, id = 1:10) %>% unlist
1:10 %>% sapply(function(id) which(x[id] == sort(x)))
lapply(iris[-5], self_lookup, 10)
hash <- function(x, nbins) {
seq_along(x) %>% cut(nbins, label = FALSE) %>% split(sort(x), .)
}
# Check to see if a value is within the values given by an array
is_within <- function(vec, x) {
(min(vec) <= x) && (x <= max(vec))
}
# Find list entry that contains a value x
lookup <- function(y, list) {
vapply(list, is_within, x = y, logical(1)) %>% which(useNames = FALSE)
}
# Combine the previous two functions
a_hash_lookup <- function(y, x, nbins) {
if (!is.list(x)) x <- hash(x, nbins)
y %>% lookup(x)
}
# Create a vectorized version
v_hash_lookup <- function(y, x, nbins) {
if (!is.list(x)) x <- hash(x, nbins)
y %>% lapply(a_hash_lookup, x = x, nbins) %>% setNames(y)
}
# Self lookup
self_lookup <- function(x, nbins, id = seq_along(x)) {
if (length(id) == 1) a_hash_lookup(x[id], x, nbins)
else v_hash_lookup(x[id], x, nbins)
}
# Test Vector
x <- rnorm(100)
# Check hash output
hash(x, 10) %>% sapply(length)
# Test atomic version
self_lookup(x, nbins = 10, id = 2)
which(x[2] == sort(x))
# Test vector version
self_lookup(x, nbins = 10, id = 1:10) %>% unlist
1:10 %>% sapply(function(id) which(x[id] == sort(x)))
lapply(iris[-5], self_lookup, 10)
hash <- function(x, nbins) {
seq_along(x) %>% cut(nbins, label = FALSE) %>% split(sort(x), .)
}
# Check to see if a value is within the values given by an array
is_within <- function(vec, x) {
(min(vec) <= x) && (x <= max(vec))
}
# Find list entry that contains a value x
lookup <- function(y, list) {
vapply(list, is_within, x = y, logical(1)) %>% which(useNames = FALSE)
}
# Combine the previous two functions
a_hash_lookup <- function(y, x, nbins) {
if (!is.list(x)) x <- hash(x, nbins)
y %>% lookup(x)
}
# Create a vectorized version
v_hash_lookup <- function(y, x, nbins) {
if (!is.list(x)) x <- hash(x, nbins)
y %>% lapply(a_hash_lookup, x = x, nbins) %>% setNames(y)
}
# Self lookup
self_lookup <- function(x, nbins, id = seq_along(x)) {
if (length(id) == 1) a_hash_lookup(x[id], x, nbins)
else v_hash_lookup(x[id], x, nbins)
}
# Test Vector
x <- rnorm(100)
# Check hash output
hash(x, 10) %>% sapply(length)
# Test atomic version
self_lookup(x, nbins = 10, id = 2)
which(x[2] == sort(x))
# Test vector version
self_lookup(x, nbins = 10, id = 1:10) %>% unlist
1:10 %>% sapply(function(id) which(x[id] == sort(x)))
lapply(iris[-5], self_lookup, 10)
lapply(iris[-5], self_lookup, 10) %>% lapply(head, 1) %>% data.frame
lapply(iris[-5], self_lookup, 10) %>% lapply(function(vec) vec[1]) %>% data.frame
lapply(iris[-5], self_lookup, 10) %>% lapply(function(vec) vec[1])
lapply(iris[-5], self_lookup, 10)
lapply(iris[-5], self_lookup, 10) %>% lapply(function(vec) vec[[1]])
lapply(iris[-5], self_lookup, 10) %>% str
self_lookup_t <- function(x, nbins = 10, id = 1:10, trimFUN = head) {
self_lookup(x, nbins, id) %>% trimFUN(1)
}
lapply(iris[-5], self_lookup_t, 10) %>% str
self_lookup(x, nbins = 10, id = 1:10) %>% unlist
self_lookup(x, nbins = 10, id = 1:10) %>% unlist
self_lookup_t <- function(x, nbins, id = seq_along(x), trimFUN = head) {
self_lookup(x, nbins, id) %>% lapply(trimFUN, 1) %>% unlist
}
lapply(iris[-5], self_lookup_t, 10) %>% str
lapply(iris[-5], self_lookup_t, 10) %>% data.frame(iris, .) %>% head
iris[-5] %>% lapply(cut, 10) %>% data.frame(iris, .) %>% head
cut
methods("cut")
getAnywhere("cut.default")
getAnywhere(".bincode")
install.packages('serv')
install.packages('servr')
servr::jekyll()
system('jekyll')
install.packages('knitr')
servr::serve_example("make1", servr::make)
#' This is a fun hashing experiment
servr::serve_example("make2", servr::make)
install.packages('rmarkdown')
servr::serve_example("make2", servr::make)
2848/1900 * 500
x <- sample(1:10, 10)
x
trunc
is_within <- function(vec, y) {
(min(vec) <= y) && (y <= max(vec))
}
is_contained <- function(vec, y) {
y %in% vec
}
lookup <- function(y, list, lookfun = c("is_within", "is_contained")) {
FUN <- get(lookfun)
vapply(list, FUN, y = y, logical(1)) %>% which(useNames = FALSE)
}
lookup
lookup(2, hash(x, 2))
library(magrittr)
lookup(2, hash(x, 2))
hash <- function(x, nbins) {
seq_along(x) %>% cut(nbins, label = FALSE) %>% split(sort(x), .)
}
x <- sample(1:10, 10)
x
hash(x, 2)
is_within <- function(vec, y) {
(min(vec) <= y) && (y <= max(vec))
}
is_contained <- function(vec, y) {
y %in% vec
}
lookup <- function(y, list, lookfun = c("is_within", "is_contained")) {
FUN <- get(lookfun)
vapply(list, FUN, y = y, logical(1)) %>% which(useNames = FALSE)
}
lookup(2, hash(x, 2))
self_lookup <- function(x, nbins, id = seq_along(x)) {
if (length(id) == 1) a_hash_lookup(x[id], x, nbins)
else v_hash_lookup(x[id], x, nbins)
}
v_hash_lookup <- function(y, x, nbins = NULL) {
if (!is.list(x) && is.null(nbins)) {
stop("Please provide either a hash table or
both the arguments to the hash function (x, nbins)")
} else if(!is.list(x)) {
x <- hash(x, nbins)
}
y %>% lapply(a_hash_lookup, x = x) %>% setNames(y)
}
a_hash_lookup <- function(y, x, nbins = NULL, within_function = c("is_within", "is_contained")) {
if (!is.list(x) && is.null(nbins)) {
stop("Please provide either a hash table or
both the arguments to the hash function (x, nbins)")
} else if(!is.list(x)) {
x <- hash(x, nbins)
}
y %>% lookup(x, within_function)
}
length(x) %/% nbins
length(x) %/% 2
length(x) %% 2
x <- rnorm(100)
hash(x, 10) %>% sapply(length)
hash(x, 8) %>% sapply(length)
self_lookup(x, nbins = 10, id = 2)
which(x[2] == sort(x))
lookup <- function(y, list, within_function = c("is_within", "is_contained")) {
FUN <- within_function %>% match.arg %>% get
vapply(list, FUN, y = y, logical(1)) %>% which(useNames = FALSE) - 1
}
lookup <- function(y, list, within_function = c("is_within", "is_contained")) {
FUN <- within_function %>% match.arg %>% get
vapply(list, FUN, y = y, logical(1)) %>% which(useNames = FALSE) - 1
}
self_lookup(x, nbins = 10, id = 2)
lookup <- function(y, list, within_function = c("is_within", "is_contained")) {
FUN <- within_function %>% match.arg %>% get
vapply(list, FUN, y = y, logical(1)) %>% which(useNames = FALSE) %>% subtract(1)
}
self_lookup(x, nbins = 10, id = 2)
traceback()
a_hash_lookup <- function(y, x, nbins = NULL, within_function = "is_within") {
if (!is.list(x) && is.null(nbins)) {
stop("Please provide either a hash table or
both the arguments to the hash function (x, nbins)")
} else if(!is.list(x)) {
x <- hash(x, nbins)
}
y %>% lookup(x, within_function)
}
traceback()
self_lookup(x, nbins = 10, id = 2)
lookup <- function(y, list, within_function = c("is_within", "is_contained")) {
print(within_function)
FUN <- within_function %>% match.arg %>% get
vapply(list, FUN, y = y, logical(1)) %>% which(useNames = FALSE) %>% subtract(1)
}
a_hash_lookup <- function(y, x, nbins = NULL, within_function = "is_within") {
if (!is.list(x) && is.null(nbins)) {
stop("Please provide either a hash table or
both the arguments to the hash function (x, nbins)")
} else if(!is.list(x)) {
x <- hash(x, nbins)
}
y %>% lookup(x, within_function)
}
# Create a vectorized version
v_hash_lookup <- function(y, x, nbins = NULL) {
if (!is.list(x) && is.null(nbins)) {
stop("Please provide either a hash table or
both the arguments to the hash function (x, nbins)")
} else if(!is.list(x)) {
x <- hash(x, nbins)
}
y %>% lapply(a_hash_lookup, x = x) %>% setNames(y)
}
self_lookup <- function(x, nbins, id = seq_along(x)) {
if (length(id) == 1) a_hash_lookup(x[id], x, nbins)
else v_hash_lookup(x[id], x, nbins)
}
self_lookup(x, nbins = 10, id = 2)
traceback()
self_lookup(x, nbins = 10, id = 2)
lookup <- function(y, list, within_function = c("is_within", "is_contained")) {
print(within_function)
FUN <- within_function %>% match.arg(c("is_within", "is_contained")) %>% get
vapply(list, FUN, y = y, logical(1)) %>% which(useNames = FALSE) %>% subtract(1)
}
self_lookup(x, nbins = 10, id = 2)
FUN <- within_function %>% match.arg(c("is_within", "is_contained")) %>% get
vapply(list, FUN, y = y, logical(1)) %>% which(useNames = FALSE) %>% subtract(1)
}
lookup <- function(y, list, within_function = c("is_within", "is_contained")) {
FUN <- within_function %>% match.arg(c("is_within", "is_contained")) %>% get
vapply(list, FUN, y = y, logical(1)) %>% which(useNames = FALSE) %>% subtract(1)
}
self_lookup(x, nbins = 10, id = 2)
which(x[2] == sort(x))
a_hash_lookup <- function(y, x, nbins = NULL, within_function = "is_within") {
if (!is.list(x) && is.null(nbins)) {
stop("Please provide either a hash table or
both the arguments to the hash function (x, nbins)")
} else if(!is.list(x)) {
x <- hash(x, nbins)
}
y %>% lookup(x, within_function) %>% setNames(y)
}
which(x[2] == sort(x))
self_lookup(x, nbins = 10, id = 2)
a_hash_lookup <- function(y, x, nbins = NULL, within_function = "is_within") {
if (!is.list(x) && is.null(nbins)) {
stop("Please provide either a hash table or
both the arguments to the hash function (x, nbins)")
} else if(!is.list(x)) {
x <- hash(x, nbins)
}
y %>% lookup(x, within_function) %>% setNames(round(y,4))
}
v_hash_lookup <- function(y, x, nbins = NULL) {
if (!is.list(x) && is.null(nbins)) {
stop("Please provide either a hash table or
both the arguments to the hash function (x, nbins)")
} else if(!is.list(x)) {
x <- hash(x, nbins)
}
y %>% lapply(a_hash_lookup, x = x) %>% setNames(round(y,4))
}
self_lookup(x, nbins = 10, id = 2)
self_lookup(x, nbins = 10, id = 2)
which(x[2] == sort(x))
sort(x)
self_lookup(x, nbins = 10, id = 1:10) %>% unlist
1:10 %>% sapply(function(id) which(x[id] == sort(x)))
self_lookup(x, nbins = 10, id = 1:5) %>% unlist
1:5 %>% sapply(function(id) which(x[id] == sort(x)))
v_hash_lookup <- function(y, x, nbins = NULL) {
if (!is.list(x) && is.null(nbins)) {
stop("Please provide either a hash table or
both the arguments to the hash function (x, nbins)")
} else if(!is.list(x)) {
x <- hash(x, nbins)
}
y %>% lapply(a_hash_lookup, x = x)
}
self_lookup(x, nbins = 10, id = 1:5) %>% unlist
1:5 %>% sapply(function(id) which(x[id] == sort(x)))
1:5 %>% sapply(function(id) which(x[id] == sort(x))) - 1
sample(1:10, 100) %>% self_lookup(nbins = 10, id = 1:5)
sample(1:10, 100, replace = TRUE) %>% self_lookup(nbins = 10, id = 1:5)
v_hash_lookup <- function(y, x, nbins = NULL) {
if (!is.list(x) && is.null(nbins)) {
stop("Please provide either a hash table or
both the arguments to the hash function (x, nbins)")
} else if(!is.list(x)) {
x <- hash(x, nbins)
}
y %>% lapply(a_hash_lookup, x = x) %>%
lapply(setNames, NULL) %>% setNames(y)
}
hash(x, 10) %>% sapply(length)
hash(x, 8) %>% sapply(length)
self_lookup(x, nbins = 10, id = 2)
which(x[2] == sort(x)) - 1
self_lookup(x, nbins = 10, id = 1:5) %>% unlist
a_hash_lookup <- function(y, x, nbins = NULL,
within_function = "is_within",
names = TRUE) {
# Assert input
if (!is.list(x) && is.null(nbins)) {
stop("Please provide either a hash table or
both the arguments to the hash function (x, nbins)")
} else if(!is.list(x)) {
x <- hash(x, nbins)
}
# Set the names value
if (names) nms <- round(y,4)
else nms <- NULL
y %>% lookup(x, within_function) %>% setNames(nms)
}
self_lookup(x, nbins = 10, id = 2)
self_lookup(x, nbins = 10, id = 1:5) %>% unlist
v_hash_lookup <- function(y, x, nbins = NULL) {
if (!is.list(x) && is.null(nbins)) {
stop("Please provide either a hash table or
both the arguments to the hash function (x, nbins)")
} else if(!is.list(x)) {
x <- hash(x, nbins)
}
y %>% lapply(a_hash_lookup, x = x, names = FALSE) %>%
setNames(round(y, 4))
}
self_lookup(x, nbins = 10, id = 1:5) %>% unlist
1:5 %>% sapply(function(id) which(x[id] == sort(x))) - 1
self_lookup(x, nbins = 10, id = 2)
which(x[2] == sort(x)) - 1
sample(1:10, 100, replace = TRUE) %>% self_lookup(nbins = 10, id = 1:5)
self_lookup_t <- function(x, nbins, id = seq_along(x),
trimFUN = c("head", "tail", "median")) {
# Assert function input
type <- trimFUN %>% match.arg(c("head", "tail", "median"))
self_lookup(x, nbins, id) %>% {
switch (type,
head = vapply(. , head, 1, numeric(1)),
median = vapply(. , median, numeric(1)),
tail = vapply(. , tail, 1, numeric(1))
)
}
}
sample(1:10, 100, replace = TRUE) %>% self_lookup_t(nbins = 10, id = 1:5)
traceback()
self_lookup_t <- function(x, nbins, id = seq_along(x),
trimFUN = c("head", "tail", "median")) {
# Assert function input
type <- trimFUN %>% match.arg(c("head", "tail", "median"))
switch (type,
head = vapply(self_lookup(x, nbins, id), head, 1, numeric(1)),
median = vapply(self_lookup(x, nbins, id), median, numeric(1)),
tail = vapply(self_lookup(x, nbins, id), tail, 1, numeric(1))
)
}
sample(1:10, 100, replace = TRUE) %>% self_lookup_t(nbins = 10, id = 1:5)
self_lookup_t <- function(x, nbins, id = seq_along(x),
trimFUN = c("head", "tail", "median")) {
# Assert function input
type <- trimFUN %>% match.arg(c("head", "tail", "median"))
switch (type,
head = lapply(self_lookup(x, nbins, id), head, 1),
median = lapply(self_lookup(x, nbins, id), median),
tail = lapply(self_lookup(x, nbins, id), tail, 1)
)
}
sample(1:10, 100, replace = TRUE) %>% self_lookup_t(nbins = 10, id = 1:5)
?vapply
self_lookup_t <- function(x, nbins, id = seq_along(x),
trimFUN = c("head", "tail", "median")) {
# Assert function input
type <- trimFUN %>% match.arg(c("head", "tail", "median"))
switch (type,
head = vapply(self_lookup(x, nbins, id), head, 1, FUN.VALUE = numeric(1)),
median = vapply(self_lookup(x, nbins, id), median, FUN.VALUE = numeric(1)),
tail = vapply(self_lookup(x, nbins, id), tail, 1, FUN.VALUE = numeric(1))
)
}
sample(1:10, 100, replace = TRUE) %>% self_lookup_t(nbins = 10, id = 1:5)
iris[-5] %>% lapply(self_lookup_t, 10) %>% data.frame(iris, .) %>% head
getanywher("cut.default")
getAnywhere("cut.default")
getAnywhere(".bincode")
system.time(iris[-5] %>% lapply(cut, 10) %>% data.frame)
system.time(iris[-5] %>% lapply(self_lookup_t, 10) %>% data.frame)
