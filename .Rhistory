v_hash_lookup(x, nbins = 10, id = 1:10)
1:10 %>% sapply(function(id) which(x[id] == sort(x)))
# A more general application
binned <- iris %>% Filter(is.numeric, .) %>%
lapply(v_hash_lookup, nbins = 10, id = seq_len(nrow(.)))
str(binned)
binned <- iris %>% Filter(is.numeric, .) %>%
lapply(function(vec) v_hash_lookup(vec, nbins = 10, id = seq_along(vec)))
str(binned)
binned
# Separate a vector into equal-value bins, the remainder gets its own bin
hash <- function(x, nbins) {
seq_along(x) %>% cut(nbins, label = FALSE) %>% split(sort(x), .)
}
# Find list entry that contains a value x
lookup <- function(x, list) {
vapply(list, function(vec) x %in% vec, logical(1)) %>% which
}
# Combine the previous two functions
a_hash_lookup <- function(vec, nbins, id) {
vec[id] %>% lookup(hash(vec, nbins)) %>% setNames(id)
}
# Create a vectorized version
v_hash_lookup <- Vectorize(a_hash_lookup, vectorize.args = "id")
# Test Vector
x <- rnorm(100)
# Test atomic version
a_hash_lookup(x, nbins = 10, id = 2)
which(x[2] == sort(x))
# Test vector version
v_hash_lookup(x, nbins = 10, id = 1:10)
1:10 %>% sapply(function(id) which(x[id] == sort(x)))
v_hash_lookup(x, nbins = 10, id = seq_along(x))
v_hash_lookup(x, nbins = 10, id = 1:99)
v_hash_lookup(x, nbins = 10, id = 1:10)
v_hash_lookup(x, nbins = 10, id = 1:20)
v_hash_lookup(x, nbins = 10, id = 1:50)
v_hash_lookup <- function(vec, nbins, id) {
hashed <- hash(vec, nbins)
vec[id] %>% vapply(lookup, hashed, numeric(1))
}
a_hash_lookup(x, nbins = 10, id = 2)
which(x[2] == sort(x))
v_hash_lookup(x, nbins = 10, id = 1:10)
v_hash_lookup <- function(vec, nbins, id) {
hashed <- hash(vec, nbins)
vec[id] %>% vapply(lookup, list = hashed, numeric(1))
}
v_hash_lookup(x, nbins = 10, id = 1:10)
v_hash_lookup <- function(vec, nbins, id) {
hashed <- hash(vec, nbins)
vec[id] %>% vapply(lookup, list = hashed, numeric(1)) %>% setNames(id)
}
v_hash_lookup(x, nbins = 10, id = 1:10)
which(sapply(iris, is.numeric))
iris %>% which(sapply(., is.numeric))
v_hash_lookup <- function(vec, nbins, id = seq_along(vec)) {
hashed <- hash(vec, nbins)
vec[id] %>% vapply(lookup, list = hashed, numeric(1)) %>% setNames(id)
}
v_hash_lookup(x, nbins = 10)
str(iris)
iris[-5] %>% mutate_each(funs(v_hash_lookup(., 10)))
iris[-5] %>% lapply(v_hash_lookup, nbins = 10)
iris[-5] %>% lapply(v_hash_lookup, nbins = 10)
iris[-5] %>% lapply(v_hash_lookup, nbins = 10)
iris[-5] %>% lapply(v_hash_lookup, nbins = 10)
v_hash_lookup <- function(vec, nbins, id = seq_along(vec)) {
hashed <- hash(vec, nbins)
vec[id] %>% vapply(lookup, list = hashed, numeric(2)) %>% setNames(id)
}
iris[-5] %>% lapply(v_hash_lookup, nbins = 10)
v_hash_lookup <- function(vec, nbins, id = seq_along(vec)) {
hashed <- hash(vec, nbins)
vec[id] %>% lapply(lookup, list = hashed) %>% setNames(id)
}
iris[-5] %>% lapply(v_hash_lookup, nbins = 10)
lookup <- function(x, list, cut_fun = head) {
vapply(list, function(vec) x %in% vec, logical(1)) %>% which %>% cut_fun(1)
}
iris[-5] %>% lapply(v_hash_lookup, nbins = 10)
v_hash_lookup <- function(vec, nbins, id = seq_along(vec)) {
hashed <- hash(vec, nbins)
vec[id] %>% vapply(lookup, list = hashed, numeric(1)) %>% setNames(id)
}
iris[-5] %>% lapply(v_hash_lookup, nbins = 10)
iris[-5] %>% lapply(v_hash_lookup, nbins = 10) %>% str
iris[-5] %<>% lapply(v_hash_lookup, nbins = 10) %>% str %>%
setNames(paste0("binned_", names(.)))
iris[-5] %<>% lapply(v_hash_lookup, nbins = 10) %>%
setNames(paste0("binned_", names(.)))
iris[-5] %<>% lapply(v_hash_lookup, nbins = 10) %>%
setNames(paste0("binned_", names(.)))
rm(iris)
v_hash_lookup <- function(vec, nbins, id = seq_along(vec)) {
vec[id] %>% vapply(lookup, list = hash(vec, nbins), numeric(1)) %>% setNames(id)
}
bin_numeric <- function(data, nbins, cols = NULL) {
binned <- if (is.null(cols)) {
Filter(is.numeric, data) %>% lapply(v_hash_lookup, nbins = nbins)
} else {
data[cols] %>% lapply(v_hash_lookup, nbins = nbins)
}
binned %>% setNames(paste0("binned_", names(.))) %>% inset(data, val = .)
}
iris %>% bin_numeric(10) %>% head
bin_numeric <- function(data, nbins, cols = NULL) {
binned <- if (is.null(cols)) {
Filter(is.numeric, data) %>% lapply(v_hash_lookup, nbins = nbins)
} else {
data[cols] %>% lapply(v_hash_lookup, nbins = nbins)
}
binned %>% setNames(paste0("binned_", names(.))) %>% inset(data, names(.), val = .)
}
iris %>% bin_numeric(10) %>% head
bin_numeric <- function(data, nbins, cols = NULL) {
binned <- if (is.null(cols)) {
Filter(is.numeric, data) %>% lapply(v_hash_lookup, nbins = nbins)
} else {
data[cols] %>% lapply(v_hash_lookup, nbins = nbins)
}
binned %>% setNames(paste0("binned_", names(.))) %>% inset(data, names(.), val = .)
}
iris %>% bin_numeric(10) %>% head
bin_numeric <- function(data, nbins, cols = NULL) {
binned <- if (is.null(cols)) {
Filter(is.numeric, data) %>% lapply(v_hash_lookup, nbins = nbins)
} else {
data[cols] %>% lapply(v_hash_lookup, nbins = nbins)
}
binned %>% setNames(paste0("binned_", names(.))) %>% inset2(data, names(.), val = .)
}
iris %>% bin_numeric(10) %>% head
bin_numeric <- function(data, nbins, cols = NULL) {
binned <- if (is.null(cols)) {
Filter(is.numeric, data) %>% lapply(v_hash_lookup, nbins = nbins)
} else {
data[cols] %>% lapply(v_hash_lookup, nbins = nbins)
}
binned %>% setNames(paste0("binned_", names(.))) %>% inset(data, names(.), val = .)
}
iris %>% bin_numeric(10) %>% head
bin_numeric <- function(data, nbins, cols = NULL) {
binned <- if (is.null(cols)) {
Filter(is.numeric, data) %>% lapply(v_hash_lookup, nbins = nbins)
} else {
data[cols] %>% lapply(v_hash_lookup, nbins = nbins)
}
binned %>% setNames(paste0("binned_", names(.))) %>% inset(data, names(.), val = .)
}
iris %>% bin_numeric(10) %>% head
`[<-.data.frame`
bin_numeric <- function(data, nbins, cols = NULL) {
binned <- if (is.null(cols)) {
Filter(is.numeric, data) %>% lapply(v_hash_lookup, nbins = nbins)
} else {
data[cols] %>% lapply(v_hash_lookup, nbins = nbins)
}
binned %>% setNames(paste0("binned_", names(.))) %>% data.frame(data, .)
}
iris %>% bin_numeric(10) %>% head
install.packages('servr')
is_within <- function(x, vec) {
min(vec) <= x && x <= max(vec)
}
is_within(5, 1:10)
is_within(11, 1:10)
sort(rnorm(100)) %>% cut(10)
hash <- function(x, nbins) {
seq_along(x) %>% cut(nbins, label = FALSE) %>% split(sort(x), .)
}
# Check to see if a value is within the values given by an array
is_within <- function(vec, x) {
min(vec) <= x && x <= max(vec)
}
# Find list entry that contains a value x
lookup <- function(x, list, cut_fun = head) {
vapply(list, is_within, x) %>% which
}
# Combine the previous two functions
a_hash_lookup <- function(y, x, nbins) {
if (!is.list(x)) x <- hash(x, nbins)
y %>% lookup(x) %>% setNames(y)
}
# Create a vectorized version
v_hash_lookup <- function(y, x, nbins) {
if (!is.list(x)) x <- hash(x, nbins)
y %>% lapply(a_hash_lookup, x, nbins) %>% setNames(y)
}
# Self lookup
self_lookup <- function(x, nbins, id) {
if (length(id) == 1) a_hash_lookup(x[id], x, nbins)
else v_hash_lookup(x[id], x, nbins)
}
# Test Vector
x <- rnorm(100)
# Test atomic version
self_lookup(x, nbins = 10, id = 2)
which(x[2] == sort(x))
self_lookup(x, nbins = 10, id = 1:10)
1:10 %>% sapply(function(id) which(x[id] == sort(x)))
self_lookup(x, nbins = 10, id = 2)
hash <- function(x, nbins) {
seq_along(x) %>% cut(nbins, label = FALSE) %>% split(sort(x), .)
}
# Check to see if a value is within the values given by an array
is_within <- function(vec, x) {
min(vec) <= x && x <= max(vec)
}
# Find list entry that contains a value x
lookup <- function(x, list, cut_fun = head) {
vapply(list, is_within, x) %>% which
}
# Combine the previous two functions
a_hash_lookup <- function(y, x, nbins) {
if (!is.list(x)) x <- hash(x, nbins)
y %>% lookup(x) %>% setNames(y)
}
# Create a vectorized version
v_hash_lookup <- function(y, x, nbins) {
if (!is.list(x)) x <- hash(x, nbins)
y %>% lapply(a_hash_lookup, x = x, nbins) %>% setNames(y)
}
# Self lookup
self_lookup <- function(x, nbins, id) {
if (length(id) == 1) a_hash_lookup(x[id], x, nbins)
else v_hash_lookup(x[id], x, nbins)
}
# Test Vector
x <- rnorm(100)
# Test atomic version
self_lookup(x, nbins = 10, id = 2)
traceback()
# Find list entry that contains a value x
lookup <- function(x, list, cut_fun = head) {
lapply(list, is_within, x) %>% which
}
traceback()
hash <- function(x, nbins) {
seq_along(x) %>% cut(nbins, label = FALSE) %>% split(sort(x), .)
}
# Check to see if a value is within the values given by an array
is_within <- function(vec, x) {
min(vec) <= x && x <= max(vec)
}
# Find list entry that contains a value x
lookup <- function(x, list, cut_fun = head) {
vapply(list, is_within, x) %>% which
}
# Combine the previous two functions
a_hash_lookup <- function(y, x, nbins) {
if (!is.list(x)) x <- hash(x, nbins)
y %>% lookup(x) %>% setNames(y)
}
# Create a vectorized version
v_hash_lookup <- function(y, x, nbins) {
if (!is.list(x)) x <- hash(x, nbins)
y %>% lapply(a_hash_lookup, x = x, nbins) %>% setNames(y)
}
# Self lookup
self_lookup <- function(x, nbins, id) {
if (length(id) == 1) a_hash_lookup(x[id], x, nbins)
else v_hash_lookup(x[id], x, nbins)
}
# Test Vector
x <- rnorm(100)
# Test atomic version
self_lookup(x, nbins = 10, id = 2)
traceback()
lookup <- function(x, list, cut_fun = head) {
vapply(list, is_within, x = x, logical(1)) %>% which
}
hash <- function(x, nbins) {
seq_along(x) %>% cut(nbins, label = FALSE) %>% split(sort(x), .)
}
# Check to see if a value is within the values given by an array
is_within <- function(vec, x) {
min(vec) <= x && x <= max(vec)
}
# Find list entry that contains a value x
lookup <- function(x, list, cut_fun = head) {
vapply(list, is_within, x) %>% which
}
# Combine the previous two functions
a_hash_lookup <- function(y, x, nbins) {
if (!is.list(x)) x <- hash(x, nbins)
y %>% lookup(x) %>% setNames(y)
}
# Create a vectorized version
v_hash_lookup <- function(y, x, nbins) {
if (!is.list(x)) x <- hash(x, nbins)
y %>% lapply(a_hash_lookup, x = x, nbins) %>% setNames(y)
}
# Self lookup
self_lookup <- function(x, nbins, id) {
if (length(id) == 1) a_hash_lookup(x[id], x, nbins)
else v_hash_lookup(x[id], x, nbins)
}
# Test Vector
x <- rnorm(100)
# Test atomic version
self_lookup(x, nbins = 10, id = 2)
hash <- function(x, nbins) {
seq_along(x) %>% cut(nbins, label = FALSE) %>% split(sort(x), .)
}
# Check to see if a value is within the values given by an array
is_within <- function(vec, x) {
(min(vec) <= x) && (x <= max(vec))
}
# Find list entry that contains a value x
lookup <- function(x, list, cut_fun = head) {
vapply(list, is_within, x = x, logical(1)) %>% which
}
hash(x)
hash(x, 10)
vapply(hash(x), is_within, x = 2, logical(1)) %>% which
vapply(hash(x, 10), is_within, x = 2, logical(1)) %>% which
lookup(2, hash(x, 10))
hash <- function(x, nbins) {
seq_along(x) %>% cut(nbins, label = FALSE) %>% split(sort(x), .)
}
# Check to see if a value is within the values given by an array
is_within <- function(vec, x) {
(min(vec) <= x) && (x <= max(vec))
}
# Find list entry that contains a value x
lookup <- function(y, list) {
vapply(list, is_within, x = y, logical(1)) %>% which
}
# Combine the previous two functions
a_hash_lookup <- function(y, x, nbins) {
if (!is.list(x)) x <- hash(x, nbins)
y %>% lookup(x) %>% setNames(y)
}
# Create a vectorized version
v_hash_lookup <- function(y, x, nbins) {
if (!is.list(x)) x <- hash(x, nbins)
y %>% lapply(a_hash_lookup, x = x, nbins) %>% setNames(y)
}
# Self lookup
self_lookup <- function(x, nbins, id) {
if (length(id) == 1) a_hash_lookup(x[id], x, nbins)
else v_hash_lookup(x[id], x, nbins)
}
# Test Vector
x <- rnorm(100)
# Test atomic version
self_lookup(x, nbins = 10, id = 2)
which(x[2] == sort(x))
hash(x, 10) %>% sapply(length)
self_lookup(x, nbins = 10, id = 1:10)
v_hash_lookup <- function(y, x, nbins) {
if (!is.list(x)) x <- hash(x, nbins)
y %>% lapply(a_hash_lookup, x = x, nbins)
}
1:10 %>% sapply(function(id) which(x[id] == sort(x)))
self_lookup(x, nbins = 10, id = 1:10)
self_lookup(x, nbins = 10, id = 2)
self_lookup(x, nbins = 10, id = 1:10) %>% unlist
self_lookup <- function(x, nbins, id = seq_along(x)) {
if (length(id) == 1) a_hash_lookup(x[id], x, nbins)
else v_hash_lookup(x[id], x, nbins)
}
lapply(iris[-5], self_lookup, 10)
a_hash_lookup <- function(y, x, nbins) {
if (!is.list(x)) x <- hash(x, nbins)
y %>% lookup(x)
}
# Create a vectorized version
v_hash_lookup <- function(y, x, nbins) {
if (!is.list(x)) x <- hash(x, nbins)
y %>% lapply(a_hash_lookup, x = x, nbins) %>% setNames(y)
}
lapply(iris[-5], self_lookup, 10)
#' This is a fun hashing experiment
# Prelim
library(magrittr)
library(dplyr)
# Separate a vector into equal-value bins, cut reallocates overflow
hash <- function(x, nbins) {
seq_along(x) %>% cut(nbins, label = FALSE) %>% split(sort(x), .)
}
# Check to see if a value is within the values given by an array
is_within <- function(vec, x) {
(min(vec) <= x) && (x <= max(vec))
}
# Find list entry that contains a value x
lookup <- function(y, list) {
vapply(list, is_within, x = y, logical(1)) %>% which
}
# Combine the previous two functions
a_hash_lookup <- function(y, x, nbins) {
if (!is.list(x)) x <- hash(x, nbins)
y %>% lookup(x)
}
# Create a vectorized version
v_hash_lookup <- function(y, x, nbins) {
if (!is.list(x)) x <- hash(x, nbins)
y %>% lapply(a_hash_lookup, x = x, nbins) %>% setNames(y)
}
# Self lookup
self_lookup <- function(x, nbins, id = seq_along(x)) {
if (length(id) == 1) a_hash_lookup(x[id], x, nbins)
else v_hash_lookup(x[id], x, nbins)
}
# Test Vector
x <- rnorm(100)
# Check hash output
hash(x, 10) %>% sapply(length)
# Test atomic version
self_lookup(x, nbins = 10, id = 2)
which(x[2] == sort(x))
# Test vector version
self_lookup(x, nbins = 10, id = 1:10) %>% unlist
1:10 %>% sapply(function(id) which(x[id] == sort(x)))
lapply(iris[-5], self_lookup, 10)
hash <- function(x, nbins) {
seq_along(x) %>% cut(nbins, label = FALSE) %>% split(sort(x), .)
}
# Check to see if a value is within the values given by an array
is_within <- function(vec, x) {
(min(vec) <= x) && (x <= max(vec))
}
# Find list entry that contains a value x
lookup <- function(y, list) {
vapply(list, is_within, x = y, logical(1)) %>% which(useNames = FALSE)
}
# Combine the previous two functions
a_hash_lookup <- function(y, x, nbins) {
if (!is.list(x)) x <- hash(x, nbins)
y %>% lookup(x)
}
# Create a vectorized version
v_hash_lookup <- function(y, x, nbins) {
if (!is.list(x)) x <- hash(x, nbins)
y %>% lapply(a_hash_lookup, x = x, nbins) %>% setNames(y)
}
# Self lookup
self_lookup <- function(x, nbins, id = seq_along(x)) {
if (length(id) == 1) a_hash_lookup(x[id], x, nbins)
else v_hash_lookup(x[id], x, nbins)
}
# Test Vector
x <- rnorm(100)
# Check hash output
hash(x, 10) %>% sapply(length)
# Test atomic version
self_lookup(x, nbins = 10, id = 2)
which(x[2] == sort(x))
# Test vector version
self_lookup(x, nbins = 10, id = 1:10) %>% unlist
1:10 %>% sapply(function(id) which(x[id] == sort(x)))
lapply(iris[-5], self_lookup, 10)
hash <- function(x, nbins) {
seq_along(x) %>% cut(nbins, label = FALSE) %>% split(sort(x), .)
}
# Check to see if a value is within the values given by an array
is_within <- function(vec, x) {
(min(vec) <= x) && (x <= max(vec))
}
# Find list entry that contains a value x
lookup <- function(y, list) {
vapply(list, is_within, x = y, logical(1)) %>% which(useNames = FALSE)
}
# Combine the previous two functions
a_hash_lookup <- function(y, x, nbins) {
if (!is.list(x)) x <- hash(x, nbins)
y %>% lookup(x)
}
# Create a vectorized version
v_hash_lookup <- function(y, x, nbins) {
if (!is.list(x)) x <- hash(x, nbins)
y %>% lapply(a_hash_lookup, x = x, nbins) %>% setNames(y)
}
# Self lookup
self_lookup <- function(x, nbins, id = seq_along(x)) {
if (length(id) == 1) a_hash_lookup(x[id], x, nbins)
else v_hash_lookup(x[id], x, nbins)
}
# Test Vector
x <- rnorm(100)
# Check hash output
hash(x, 10) %>% sapply(length)
# Test atomic version
self_lookup(x, nbins = 10, id = 2)
which(x[2] == sort(x))
# Test vector version
self_lookup(x, nbins = 10, id = 1:10) %>% unlist
1:10 %>% sapply(function(id) which(x[id] == sort(x)))
lapply(iris[-5], self_lookup, 10)
lapply(iris[-5], self_lookup, 10) %>% lapply(head, 1) %>% data.frame
lapply(iris[-5], self_lookup, 10) %>% lapply(function(vec) vec[1]) %>% data.frame
lapply(iris[-5], self_lookup, 10) %>% lapply(function(vec) vec[1])
lapply(iris[-5], self_lookup, 10)
lapply(iris[-5], self_lookup, 10) %>% lapply(function(vec) vec[[1]])
lapply(iris[-5], self_lookup, 10) %>% str
self_lookup_t <- function(x, nbins = 10, id = 1:10, trimFUN = head) {
self_lookup(x, nbins, id) %>% trimFUN(1)
}
lapply(iris[-5], self_lookup_t, 10) %>% str
self_lookup(x, nbins = 10, id = 1:10) %>% unlist
self_lookup(x, nbins = 10, id = 1:10) %>% unlist
self_lookup_t <- function(x, nbins, id = seq_along(x), trimFUN = head) {
self_lookup(x, nbins, id) %>% lapply(trimFUN, 1) %>% unlist
}
lapply(iris[-5], self_lookup_t, 10) %>% str
lapply(iris[-5], self_lookup_t, 10) %>% data.frame(iris, .) %>% head
iris[-5] %>% lapply(cut, 10) %>% data.frame(iris, .) %>% head
cut
methods("cut")
getAnywhere("cut.default")
getAnywhere(".bincode")
